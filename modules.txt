#!/bin/bash
module load python/3.4.1-fasrc01
module load legacy/0.0.1-fasrc01
module load centos6/cython-0.20_python-3.3.2
module load gcc/6.2.0-fasrc02


srun --mem-per-cpu=2300 -p general -n 32 --pty -t 0-06:00 /bin/bash

#srun --mem-per-cpu=4000 -p holyseasgpu -n 64 --gres=gpu:1 --constraint=cuda-7.5 --pty -t 0-06:00 /bin/bash

python setup.py build_ext --inplace

python main.py


sbatch --array=4,8,16,32,64 cython_bash.sh



cdef void reduce(double[::,::] out, double * C, int s, int t, int N, int stop) nogil:
    cdef size_t k,j

    for k in range(N):
        for j in range(N):
            if (s+k < stop) & (t+j < stop):
                out[s+k,t+j] += C[N*k + j]

cdef void mmb(double[::,::] X, double[::,::] Y, double[::,::] out, int nthreads, int[::,::] step1, int[::,::] step2, int S, int chunk, int N, int J, int K):
    cdef size_t a, b, k, j, n, s,t
    cdef int tid
    cdef double *A
    cdef double *B
    cdef double *C

    with nogil, parallel(num_threads = nthreads):
        tid = threadid()
        A = <double *>(malloc (10*J * chunk * sizeof(double)))
        B = <double *>(malloc (10*J * chunk * sizeof(double)))
        C = <double *>(malloc (10*chunk * chunk * sizeof(double)))
        for s in range(S):
            for a in range(chunk):
                if ((a + step1[tid,s]) < N) & ((a + step2[tid,s])<K):
                    for b in range(J):
                        A[a*J + b] = X[a + step1[tid,s], b]
                        B[a*J + b] = Y[b, a + step2[tid,s]]
            for k in range(chunk):
                for j in range(chunk):
                    if ((k + step1[tid,s]) < N) & ((j + step2[tid,s])<K):
                        for t in range(J):
                            C[k*J + j] = C[k*J + j] + A[k*J + t] * B[j*J + t]
            for n in prange(nthreads):
                reduce(out, C, step1[tid,s], step2[tid,s], chunk, N)


def matMult_block(double[::,::] X, double[::,::] Y, double[::,::] out, int nthreads, int[::, ::] step1, int[::, ::] step2, int chunk):
    cdef int S = step1.shape[1]
    cdef int K = Y.shape[1]
    cdef int N = X.shape[0]
    cdef int J = Y.shape[0]
    cdef double[::,::] Xc = X
    cdef double[::,::] Yc = Y
    cdef double[::,::] outC = out
    cdef int nt = nthreads
    cdef int[::,::] stepC1 = step1
    cdef int[::,::] stepC2 = step2
    cdef int chunkC = chunk

    mmb(Xc, Yc, outC, nt, stepC1, stepC2, S, chunkC, N, J, K)
    return np.asarray(outC)